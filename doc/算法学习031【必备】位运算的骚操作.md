# 位运算的骚操作

位运算有很多奇技淫巧，位运算的速度非常快，仅次于赋值操作，常数时间极好！

关于位运算还有非常重要的内容：

N皇后问题用位运算实现，将在【必备】课程里讲到

状态压缩的动态规划，将在【扩展】课程里讲到

## 题目一、 判断一个整数是不是2的幂

给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。

如果是，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `x` 使得 `n == 2x` ，则认为 `n` 是 2 的幂次方。

**思路：**提取出最右侧的1来，然后计算这个最右侧的1的值是不是当前的值，如果是说明n就是2的幂次方。

> https://leetcode.cn/problems/power-of-two/

**思路：**如果它自己就是当前数最右侧的1，那么说明就是

```java
public boolean isPowerOfTwo(int n) {
    return n > 0 && n == (n & -n);
}
```

## 题目二、 判断一个整数是不是3的幂

> https://leetcode.cn/problems/power-of-three/

```
// 如果一个数字是3的某次幂，那么这个数一定只含有3这个质数因子
// 1162261467是int型范围内，最大的3的幂，它是 3^19 次方
// 这个1162261467只含有3这个质数因子，如果n也是只含有3这个质数因子，那么
// 1162261467 % n == 0
// 反之如果1162261467 % n != 0 说明n一定含有其他因子
```

```java
public static boolean isPowerOfThree(int n) {
    return n > 0 && 1162261467 % n == 0;
}
```

## 题目三、 返回大于等于n的最小的2的幂

HashMap中获取大于等于n的最小2的幂的长度。

**思路：**n-1，然后将最高位出现的1向右移动1次，11 =》 在移动2次，最高4位就是全都是1，再移动4次，那么最高位8都是1，一直到移动16次，那么最高位32位都是1。

```java
public static int near2power(int n) {
    if (n <= 0) {
       return 1;
    }
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return n + 1;
}
```

## 题目四、 区间[left, right]内所有数字 & 的结果

给你两个整数 `left` 和 `right` ，表示区间 `[left, right]` ，

返回此区间内所有数字 **按位与** 的结果（包含 `left` 、`right` 端点）。

**思路：** 

1. 每次都减去1然后和自己异或，直到 left = right（right & (right - 1);）
2. 每次都减去最右侧的1，本质和上面的 写法是一样的

```java
 public static int rangeBitwiseAnd(int left, int right) {
        while (left < right) {
            // 每次都减去最右侧的1，直到 left = right
            right -= right & -right;
            // 每次减去1，进行异或直到 left = right
//            right = right & (right - 1);
        }
        return right;
    }
```

## 题目五、反转一个二进制的状态，不是0变1、1变0，是逆序。

> https://leetcode.cn/problems/reverse-bits/

**思路：**将一个数进行反转，那么第一反转一位，第二次反转两位，直到第四次反转后，然后使用左移和右移或进去就是答案。

```java
// 逆序二进制的状态
public static int reverseBits(int n) {
    n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
    n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
    n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
    n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
    n = (n >>> 16) | (n << 16);
    return n;
}
```

## 题目六、返回一个数二进制中有几个1

两个整数之间的 [汉明距离](https://baike.baidu.com/item/汉明距离) 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 `x` 和 `y`，计算并返回它们之间的汉明距离。

超自然版，看完佩服大牛的脑洞，能爽一整天

**解法1就是每次提取最右侧的1，然后累加，直到这个数为0.**

```java
public int hammingDistance1(int x, int y) {
    int xor = x ^ y, ans = 0;
    while (xor != 0) {
        xor &= xor - 1;
        ans++;
    }
    return ans;
}
```

**其实就是求，x ^ y 之后一共有多少个1.**

**思路：**

1. 求原始的每个长度为1的位置上1出现的次数：(n & 0x55555555) + ((n >>> 1) & 0x55555555)

2. 然后再去原始n的长度为2的位置上的1出现的次数：(n & 0x33333333) + ((n >>> 2) & 0x33333333)
3. 一次类推到原始的长度为16的位置上的1出现的次数 ： (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff)
4. 最后相加就是总的32位长度上1出现的次数。

```java
public static int hammingDistance(int x, int y) {
    return cntOnes(x ^ y);
}

// 返回n的二进制中有几个1
// 这个实现脑洞太大了
public static int cntOnes(int n) {
    n = (n & 0x55555555) + ((n >>> 1) & 0x55555555);
    n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
    n = (n & 0x0f0f0f0f) + ((n >>> 4) & 0x0f0f0f0f);
    n = (n & 0x00ff00ff) + ((n >>> 8) & 0x00ff00ff);
    n = (n & 0x0000ffff) + ((n >>> 16) & 0x0000ffff);
    return n;
}
```

## 总结

题目5和题目6代码看着跟脑子有大病一样，承认很强但似乎有点太嘚瑟了，是这样吗？

不是的，条件判断相比于赋值、位运算、算术运算是稍慢的，所以其实有现实意义

但是不需要追求在练算法过程中尽量少写条件判断，

那样会带来很多不必要的困扰，还是要写尽量直白、尤其是自己能理解的代码最好

大牛的实现欣赏完理解就好，下次当模版直接用