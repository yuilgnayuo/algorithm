# 位圖

## 位图原理

其实就是用bit组成的数组来存放值，用bit状态1、0代表存在、不存在，取值和存值操作都用位运算

限制是必须为连续范围且不能过大。好处是极大的节省空间，因为1个数字只占用1个bit的空间。

## 位图的实现

Bitset(int n)：初始化位图的大小，只支持0~n-1所有数字的增删改查

void add(int num)：把num加入到位图

void remove(int num)：把num从位图中删除

void reverse(int num)：如果位图里没有num，就加入；如果位图里有num，就删除

boolean contains(int num)：查询num是否在位图中

将采用对数器验证，当你找不到测试链接的时候就用对数器验证，而且对数器验证更稳妥、更能练习debug能力

# 實現：

**細節**：**一個 int可以代表 0～31 的數字**的存在或者不存在。那麼總共需要多少個index = （n + 32 - 1 ）/ 32 。

```java
public static class Bitset {
    int[] set;

    ///  1 ~ n-1
    public Bitset(int n) {
        //  a/b 需要向上取整，(a + b - 1)/b
        set = new int[(n + 32 - 1) / 32];
    }

    // 把num加入到位图
    void add(int num) {
        int idx = num / 32;
        int bit = num % 32;
        set[idx] |= 1 << bit;
    }

    // 把num从位图中删除
    void remove(int num) {
        set[num / 32] &= ~(1 << num % 32);
    }

    // 如果位图里没有num，就加入；如果位图里有num，就删除
   // 0^1 => 1, 1^1 = 0
    void reverse(int num) {
        set[num / 32] ^= 1 << num % 32;
    }

    // 查询num是否在位图中
    boolean contains(int num) {
        return ((set[num / 32] >> (num % 32)) & 1) == 1;
    }
}
```

**Testing:**

```java
static void main() {
    int n = 1000;
    int testTimes = 10000;
    System.out.println("测试开始");
    // 实现的位图结构
    Bitset bitSet = new Bitset(n);
    // 直接用HashSet做对比测试
    HashSet<Integer> hashSet = new HashSet<>();
    System.out.println("调用阶段开始");
    for (int i = 0; i < testTimes; i++) {
        double decide = Math.random();
        // number -> 0 ~ n-1，等概率得到
        int number = (int) (Math.random() * n);
        if (decide < 0.333) {
            bitSet.add(number);
            hashSet.add(number);
        } else if (decide < 0.666) {
            bitSet.remove(number);
            hashSet.remove(number);
        } else {
            bitSet.reverse(number);
            if (hashSet.contains(number)) {
                hashSet.remove(number);
            } else {
                hashSet.add(number);
            }
        }
    }
    System.out.println("调用阶段结束");
    System.out.println("验证阶段开始");
    for (int i = 0; i < n; i++) {
        if (bitSet.contains(i) != hashSet.contains(i)) {
            System.out.println("出错了!");
        }
    }
    System.out.println("验证阶段结束");
    System.out.println("测试结束");
}
```

## BitSet  實現 

> https://leetcode.cn/problems/design-bitset/

请你实现 `Bitset` 类。

- `Bitset(int size)` 用 `size` 个位初始化 Bitset ，所有位都是 `0` 。
- `void fix(int idx)` 将下标为 `idx` 的位上的值更新为 `1` 。如果值已经是 `1` ，则不会发生任何改变。
- `void unfix(int idx)` 将下标为 `idx` 的位上的值更新为 `0` 。如果值已经是 `0` ，则不会发生任何改变。
- `void flip()` 翻转 Bitset 中每一位上的值。换句话说，所有值为 `0` 的位将会变成 `1` ，反之亦然。
- `boolean all()` 检查 Bitset 中 **每一位** 的值是否都是 `1` 。如果满足此条件，返回 `true` ；否则，返回 `false` 。
- `boolean one()` 检查 Bitset 中 是否 **至少一位** 的值是 `1` 。如果满足此条件，返回 `true` ；否则，返回 `false` 。
- `int count()` 返回 Bitset 中值为 1 的位的 **总数** 。
- `String toString()` 返回 Bitset 的当前组成情况。注意，在结果字符串中，第 `i` 个下标处的字符应该与 Bitset 中的第 `i` 位一致。

**優化點：直接使用reverse變量，省去了每個位置的反轉。**《--重要。

```java
class Bitset {
        int[] set;
        int zero;
        int one;
        int size;
        boolean reverse; // 標記是否反轉了

        public Bitset(int n) {
            set = new int[(n + 31) / 32];
            reverse = false;
            zero = n;
            size = n;
            one = 0;
        }

        // 将下标为 idx 的位上的值更新为 1 。
        // 如果值已经是 1 ，则不会发生任何改变。
        public void fix(int i) {
            int idx = i / 32;
            int bit = i % 32;
            int jud = 1 << bit;
            // 沒有反轉
            if (!reverse) {
                // 0: 不存在，1:存在
                if ((set[idx] & jud) == 0) {
                    set[idx] |= jud;
                    one++;
                    zero--;
                }
            } else {
                // 反轉之後所有位置變為：0-》1，1=》0
                // 反轉之後：0:存在，1:不存在
                if ((set[idx] & jud) != 0) {
                    one++;
                    zero--;
                    set[idx] ^= jud;
                }
            }
        }

        // 将下标为 idx 的位上的值更新为 0 。
        // 如果值已经是 0 ，则不会发生任何改变。
        public void unfix(int i) {
            int idx = i / 32;
            int bit = i % 32;
            int jud = 1 << bit;
            // 沒有反轉
            if (!reverse) {
                // 0: 不存在，1:存在
                if ((set[idx] & jud) != 0) {
                    set[idx] ^= jud;
                    one--;
                    zero++;
                }
            } else {
                // 反轉之後所有位置變為：0-》1，1=》0
                // 反轉之後：0:存在，1:不存在
                if ((set[idx] & jud) == 0) {
                    one--;
                    zero++;
                    set[idx] |= jud;
                }
            }
        }

        // 不需要真正的把所有位都反轉，而是在fix和unfix以及toString的時候
        // 根據狀態來判斷是否反轉了
        public void flip() {
            int tmp = zero;
            zero = one;
            one = tmp;
            reverse = !reverse;
        }

        public boolean all() {
            return one == size;
        }

        public boolean one() {
            return one > 0;
        }

        public int count() {
            return one;
        }

        public String toString() {
            StringBuilder sb = new StringBuilder();
            for (int i = 0, k = 0, number; i < size; k++) {
                number = set[k];
                for (int j = 0; j < 32 && i < size; j++, i++) {
                    int s = number >> j & 1;
                    s ^= reverse ? 1 : 0; // 反轉之後：1-》0，0-〉1
                    sb.append(s);
                }
            }
            return sb.toString();
        }
    }
```

