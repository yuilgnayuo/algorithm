# 异或运算的骚操作

## 异或运算性质

1. 异或运算的本质是**无进位相加**
2. 异或运算**满足交换律、结合律**：也就是同一批数字，不管异或顺序是什么，最终的结果都是一个

3. **0^n=n，n^n=0**
4. 整体异或和如果是x，整体中某个部分的异或和如果是y，那么剩下部分的异或和是x^y

主意：Nim博弈也是和异或运算相关的算法，将在后续【必备】课程里讲到

## Brian Kernighan算法 提取出最右侧的1

>  提取出二进制状态中最右侧的1

其实本质就是：对任意一个数进行 n-1然后再取反。

比如：  0 1 0 1 0 0  减1》 0 1 0 0 1 1 取反〉 1 0 1 1 0 0

​          & 1 0 1 1 0 0 = 0 0 0 1 0 0

```java
static int getRightOne(int n) {
    return n & (-n);
}
```

## 题目一、交换两个数

```java
public static void main(String[] args) {
        int a = -2323;
        int b = 10;
        a = a ^ b;
        b = a ^ b;
        a = a ^ b;
        System.out.println(a);
        System.out.println(b);

        int[] arr = {3, 5};
        swap(arr, 0, 1);
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        swap(arr, 0, 0);
        System.out.println(arr[0]);
    }

    // 当i!=j，没问题，会完成交换功能
    // 当i==j，会出错
    // 所以知道这种写法即可，并不推荐
    public static void swap(int[] arr, int i, int j) {
        arr[i] = arr[i] ^ arr[j];
        arr[j] = arr[i] ^ arr[j];
        arr[i] = arr[i] ^ arr[j];
    }
```

## 题目二、 返回两个数的最大值，不能用判断和比较操作

不用任何判断语句和比较操作，返回两个数的最大值

> https://www.nowcoder.com/practice/d2707eaf98124f1e8f1d9c18ad487f76

```java
// 必须保证n一定是0或者1
// 0变1，1变0
public static int flip(int n) {
    return n ^ 1;
}

// 非负数返回1
// 负数返回0
public static int sign(int n) {
    return flip(n >>> 31);
}

// 有溢出风险的实现
public static int getMax1(int a, int b) {
    int c = a - b;
    // c非负，returnA -> 1
    // c非负，returnB -> 0
    // c负数，returnA -> 0
    // c负数，returnB -> 1
    int returnA = sign(c);
    int returnB = flip(returnA);
    return a * returnA + b * returnB;
}

// 没有任何问题的实现
public static int getMax2(int a, int b) {
    // c可能是溢出的
    int c = a - b;
    // a的符号
    int sa = sign(a);
    // b的符号
    int sb = sign(b);
    // c的符号
    int sc = sign(c);
    // 判断A和B，符号是不是不一样，如果不一样diffAB=1，如果一样diffAB=0
    int diffAB = sa ^ sb;
    // 判断A和B，符号是不是一样，如果一样sameAB=1，如果不一样sameAB=0
    int sameAB = flip(diffAB);
    int returnA = diffAB * sa + sameAB * sc;
    int returnB = flip(returnA);
    return a * returnA + b * returnB;
}
```

## 题目三、 找到缺失的数字

给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，

找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

> https://leetcode.cn/problems/missing-number/description/

 **思路：** 异或 0～ n的每个位置的值为eor1，同时异或 从 0 ～ N 的值为eor2，那么最后 eor1 ^ eor2 就是答案。

因为eor2 是所有数的异或结果，eor1为缺少其中一个数的结果

```java
public int missingNumber(int[] arr) {
    int N = arr.length;
    int eor1 = 0;
    int eor2 = 0;
    for (int i = 0; i < N; i++) {
        eor1 ^= arr[i];
        eor2 ^= i;
    }
    eor2 ^= N;
    return eor1 ^ eor2;
}
```

## 题目四、找出现奇数次的数

**数组中1种数出现了奇数次，其他的数都出现了偶数次，返回出现了奇数次的数**

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。

找出那个只出现了一次的元素。

> https://leetcode.cn/problems/single-number/

**思路：**将数组中所有的值进行异或，那么得到的结果就是这个出现一次的数，因为偶数次数的 　A^A = 0

```java
public int singleNumber(int[] arrs) {
    int eor = 0;
    for (int arr : arrs) {
        eor ^= arr;
    }
    return eor;
}
```

## 题目五、 找出现2次的数

**数组中有2种数出现了奇数次，其他的数都出现了偶数次，返回这2种出现了奇数次的数**

给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，

其余所有元素均出现两次。 找出只出现一次的那两个元素。

你可以按 **任意顺序** 返回答案。

**思路：**

1. 先得到所有值异或的结果eor1，那么这个eor1的值就是出现奇数次的a和b的值。
2. 然后提取出eor1最右侧的1，rightOne
3. 重新遍历这个数组，如何这个数和rightOne与操作为0，那么这些数异或得到eor2，
4. 那么eor2就是这个数组中出现2次奇数中的任意一个
5. 最后将eor1和eor2进行异或，那么结果就是另外一个出现奇数的数

```java
public int[] singleNumber(int[] nums) {
    int N = nums.length;
    int eor1 = 0;
    for (int num : nums) {
        eor1 ^= num;
    }
    int rightOne = eor1 & (-eor1);
    int eor2 = 0;
    for (int num : nums) {
        if ((num & rightOne) == 0) {
            eor2 ^= num;
        }
    }
    return new int[]{eor2, eor2 ^ eor1};
}
```

## 题目六、找出现1次的数，其他数出现M次

**数组中只有1种数出现次数少于m次，其他数都出现了m次，返回出现次数小于m次的那种数**

给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，

其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。

这个题只是求出现三次和出现一次的数，但是代码是通用的出现m次，其他出现一次的通用解。

> https://leetcode.cn/problems/single-number-ii/

**思路：**

1. 求int上的32位中每个位置对应出现1的次数
2. 如果对m求余不为0，那么说明这个位置的数是出现一次的造成的
3. 最后将每个位置对m求余不为0的位，进行组合就是答案

```java
public int singleNumber(int[] nums) {
    return find(nums, 3);
}

// 已知数组中只有1种数出现次数少于m次，其他数都出现了m次
// 返回出现次数小于m次的那种数
public int find(int[] nums, int m) {
    // 每个位置有多少个1
    int[] cos = new int[32];
    for (int num : nums) {
        for (int i = 0; i < 32; i++) {
            cos[i] += (num >> i) & 1;
        }
    }
    int ans = 0;
    for (int i = 0; i < 32; i++) {
        if (cos[i] % m != 0) {
            ans |= 1 << i;
        }
    }
    return ans;
}
```