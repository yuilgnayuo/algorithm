# N皇后问题

前置知识

递归相关 : 讲解038

位运算相关 : 讲解003、030、031、032、033

解决N皇后问题的时间复杂度是O(n!)，好的方法可以大量剪枝，大量优化常数时间



## 用数组表示路径的方法

用数组表示路径的方法（经典、常数时间慢，不推荐）

1. 记录之前每一行的皇后放在了什么列，使用 path 数组表示索引对应行，值对应放在了哪列
2. 来到第i行的时候，可以根据0..i-1行皇后的位置，判断能放哪些列
3. 把能放的列都尝试一遍，每次尝试修改路径数组表示当前的决策，后续返回的答案都累加返回

**注意：**如何知道之前选择的答案，跟我来到 i 行 j 列的时候，是否冲突？

1. 列冲突，相等： j 列 == path[k] 
2. 对角线是否冲突：思考，如果冲突，必然是，上一行选择的答案， 比如为：a, b 和当前 i ，j 一定有 abs(a - i) 和 abs(b - j ) 一定相当，因为**在对角线上**，**一定是 a 或者 b 加上相同的数**

```java
// 使用数组表示路径的经典实现
public static int totalNQueens1(int n) {
    if (n < 1) return 0;
    return f(n, 0, new int[n]);
}

// 当前在 start 行尝试
// path: [0...i-1] 行上对应放置皇后的情况
private static int f(int n, int start, int[] path) {
    // start 能来到n行，说明在 0 ～ n-1 行上是正确的答案
    if (start == n) {
        return 1;
    }
    int ans = 0;
    // 当前在 j 列上尝试
    for (int j = 0; j < n; j++) {
        if (check(path, start, j)) {
            path[start] = j; // start 行 放置一个皇后
            ans += f(n, start + 1, path);
        }
    }
    return ans;
}

// 坚持如果来到 i 行，j 列的时候是否符合N皇后，在列上，对角线上都不能放对应的皇后
private static boolean check(int[] path, int i, int j) {
    // 0～i 行上，对应path已经选择的情况
    for (int k = 0; k < i; k++) {
        if (j == path[k] || (Math.abs(i - k) == Math.abs(j - path[k]))) {
            return false;
        }
    }
    return true;
}
```

## 用位运算的方法（巧妙、常数时间快，推荐）

用位运算的方法（巧妙、常数时间快，推荐）

1. int col  : 0..i-1行皇后放置的位置因为正下方向延伸的原因，哪些列不能再放皇后
2. int left : 0..i-1行皇后放置的位置因为左下方向延伸的原因，哪些列不能再放皇后
3. int right : 0..i-1行皇后放置的位置因为右下方向延伸的原因，哪些列不能再放皇后
4. 根据col、left、right，用位运算快速判断能放哪些列
5. 把能放的列都尝试一遍，每次尝试修改3个数字表示当前的决策，后续返回的答案都累加返回

**核心重点：**

1. **使用位信息来代表**：比如：**每一位**上，分别代表**那一列**上放置了皇后。第i行，代表第i位上放置了皇后
2. col 好理解：表示当前列上放置了皇后，你在其他行对应的col列上不能有皇后了
3. 记住：因为是对角线上不能放置，因此使用两个参数，left，right 分别代表：比如 i，j 位置有皇后，那么对应 i+1行上，代表左斜对角线，right：代表右斜对角线，
4. 为什么可以使用right和left？因为可以每次当来到下一行的时候，通过**left 左移动一位**和**right 右移动一位**，将上一行的限制信息带来



```java
// 位运算版本，大量优化常数时间
public static int totalNQueens2(int n) {
    if (n < 1) return 0;
    // 将所有0～n-1位上设置为1
    int limit = (1 << n) - 1;
    return f2(limit, 0, 0, 0);
}

// 分别代表：左边，右边，以及当前col上不能放置皇后了
private static int f2(int limit, int left, int right, int col) {
    // 所有位上皇后都放了，所以这是一种有限的解
    if (col == limit) return 1;
    int ban = left | right | col; // 总限制
    int candidate = ~ban & limit; // 取反，可以表示哪些位置能放置皇后
    int place = 0;
    int ans = 0;
    while (candidate != 0) {
        place = candidate & -candidate;
        candidate ^= place;
        ans += f2(limit, (left | place) >> 1, (right | place) << 1, col | place);
    }
    return ans;
}
```

**解释：**

1. 每次递归进来之后，根据之前的col，left，right的限制计算出可以放置皇后的位置
2. candidate：代表当前来的下一行上所有位置 1 为能放皇后，0 则是不能
3. 只要candidate不为0，那么就一直递归尝试，直到candidate所表示的当前行上每个位置都试过了才退出