# 二叉树高频题目

这一期和下一期视频，会讲解二叉树高频题目，但是不含树型dp的题目

树型dp问题，会放在【必备】课程的动态规划大章节部分讲述

树型dp中的换根dp问题，会放在【扩展】课程的动态规划大章节部分讲述

AVL树的实现，树的左旋、右旋，这些内容也会在【扩展】课程里讲述	

# 题目1 : 二叉树的层序遍历

> 

思路：

1. 准备一个队列
2. x弹出
3. x 有左加左，有右加右
4. 用一个hashMap记录下当前node属于哪一行，只有当来到下一行的时候，初始化下一行的ans：ans.size() == lev

普通版本：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    if (root != null) {
        Queue<TreeNode> queue = new LinkedList<>();
        HashMap<TreeNode, Integer> levs = new HashMap<>();
        queue.add(root);
        levs.put(root, 0);
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            int lev = levs.get(cur);
            if (ans.size() == lev) {
                // init lev ans
                ans.add(new ArrayList<>());
            }
            ans.get(lev).add(cur.val);
            if (cur.left != null) {
                queue.add(cur.left);
                levs.put(cur.left, lev + 1);
            }
            if (cur.right != null) {
                queue.add(cur.right);
                levs.put(cur.right, lev + 1);
            }
        }
    }
    return ans;
}
```

**优化版本：**使用数组代替队列，并且一次性收集某一高度的答案，

```java
// 如果测试数据量变大了就修改这个值
    public static int MAXN = 2001;
    // 使用数组代替队列结构
    public static TreeNode[] queue = new TreeNode[MAXN];

    public static int l, r;

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root != null) {
            l = r = 0;
            queue[r++] = root;
            while (l < r) {
                // 一次遍历一行的数据
                int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
                List<Integer> levAns = new ArrayList<>();
              // 也可以先收集答案，再进行弹出遍历
//                for (int i = l; i < r ; i++) {
//                    levAns.add(queue[i].val);
//                }
                for (int i = 0; i < size; i++) {
                    TreeNode cur = queue[l++];
                    levAns.add(cur.val);
                    if (cur.left != null) {
                        queue[r++] = cur.left;
                    }
                    if (cur.right != null) {
                        queue[r++] = cur.right;
                    }
                }
                ans.add(levAns);

            }
        }
        return ans;
    }
```

# 题目2 : 二叉树的锯齿形层序遍历

> https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/

思路：

1. 使用标准的BFS，进行宽度优先遍历
2. 使用一个标记位flag，记录下正序还是倒序记录，
3. 正序：l …… r-l
4. 倒序：r-l …… l
5. 先收集答案，再进行弹出，放入左右孩子，进行宽度优先遍历

```java
// 如果测试数据量变大了就修改这个值
public static int MAXN = 2001;
// 使用数组代替队列结构
public static TreeNode[] queue = new TreeNode[MAXN];

public static int l, r;

public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    boolean reverse = false;
    if (root != null) {
        l = r = 0;
        queue[r++] = root;
        while (l < r) {
            // 一次遍历一行的数据
            int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
            List<Integer> levAns = new ArrayList<>();
            // 先收集答案，一次收集一正行的数据
            // reverse = false ：l    -》 r-l
            // reverse = true  : r-l  -》 l
            if (!reverse) {
                for (int i = l; i < r; i++) {
                    levAns.add(queue[i].val);
                }
            } else {
                for (int i = r - 1; i >= l; i--) {
                    levAns.add(queue[i].val);
                }
            }
            // 然后宽度遍历
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue[l++];
                if (cur.left != null) {
                    queue[r++] = cur.left;
                }
                if (cur.right != null) {
                    queue[r++] = cur.right;
                }
            }
            reverse = !reverse;
            ans.add(levAns);
        }
    }
    return ans;
}
```

# 题目3 : 二叉树的最大特殊宽度

> https://leetcode.cn/problems/maximum-width-of-binary-tree/description/

**思路：**

1. 使用标准的BFS，进行宽度优先遍历
2. 准备一个index 队列，跟标准的宽度优先遍历队列一样，
3. 只是这个index队列 存的是每个值所对应的 index 值，
4. 比如：cur node的位置为index，左：index*2，右：index * 2 + 1

**问题：**为什么要记录idx，为的是，不管null的位置，只需要知道当前行，最左和最右位置，直接相减+1，就是当前行最大宽度

```java
// 如果测试数据量变大了就修改这个值
public static int MAXN = 3001;
// 使用数组代替队列结构
public static TreeNode[] queue = new TreeNode[MAXN];
public static Integer[] iq = new Integer[MAXN];

public static int l, r;

public int widthOfBinaryTree(TreeNode root) {
    int ans = 0;
    if (root != null) {
        l = r = 0;
        queue[r] = root;
        iq[r++] = 1;
        while (l < r) {
            // 一次遍历一行的数据
            int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
            // 当前正行的开始位置l，结束位置 r - 1
            ans = Math.max(ans, iq[r - 1] - iq[l] + 1);
            // 然后宽度遍历
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue[l];
                Integer idx = iq[l++];
                if (cur.left != null) {
                    queue[r] = cur.left;
                    iq[r++] = idx * 2;
                }
                if (cur.right != null) {
                    queue[r] = cur.right;
                    iq[r++] = idx * 2 + 1;
                }
            }
        }
    }
    return ans;
}
```

# 题目4 : 求二叉树的最大深度、求二叉树的最小深度

## 最大深度：

> https://leetcode.cn/problems/maximum-depth-of-binary-tree/

 思路：直接递归调用，去左树上看最大深度，右树上看最大深度，然后比较之后  + 1。 

```java
public int maxDepth(TreeNode root) {
    return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

# 最小深度

> https://leetcode.cn/problems/minimum-depth-of-binary-tree/

**思路：**

1. 空树为0，
2. 当到达叶子节点：深度为1
3. 非叶子：求左树最小，求右树最下，然后比较之后 + 1
4. 主意：初始值 ml 和 mr 不能为 0

```java
public int minDepth(TreeNode root) {
    // 当前为空树
    if (root == null) return 0;
    // 到达叶子节点
    if (root.left == null && root.right == null) return 1;
    // 左树求最小，右树求最小
    int ml = Integer.MAX_VALUE;
    if (root.left != null) {
        ml = minDepth(root.left);
    }
    int mr = Integer.MAX_VALUE;
    if (root.right != null) {
        mr = minDepth(root.right);
    }
    // 收集最小答案
    return Math.min(ml, mr) + 1;
}
```

# 题目5 : 二叉树先序序列化和反序列化

```txt
// 二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化
// 但是，二叉树无法通过中序遍历的方式实现序列化和反序列化
// 因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。
// 比如如下两棵树
//         __2
//        /
//       1
//       和
//       1__
//          \
//           2
// 补足空位置的中序遍历结果都是{ null, 1, null, 2, null}
```

> https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/

**思路：**以**先序方式**进行序列化和反序列化，如果遇到左孩子或者右孩子为空，使用特殊字符#占位。

```java
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        f(root, sb);
        return sb.toString();
    }

    private void f(TreeNode root, StringBuilder sb) {
        if (root == null) {
            sb.append("#,");
        } else {
            sb.append(root.val).append(",");
            f(root.left, sb);
            f(root.right, sb);
        }
    }


    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] datas = data.split(",");
        curIdx = 0;
        return g(datas);
    }

    // 当前数组消费到哪了
    public static int curIdx;

    private TreeNode g(String[] datas) {
        String cur = datas[curIdx++];
        if ("#".equals(cur)) {
            return null;
        } else {
            TreeNode head = new TreeNode(Integer.parseInt(cur));
            head.left = g(datas);
            head.right = g(datas);
            return head;
        }
    }
}
```

# 题目6 : 二叉树按层序列化和反序列化

> https://leetcode.cn/problems/h54YBf/description/

**思路：**以**宽度优先**的方式进行序列化和反序列化，如果遇到左孩子或者右孩子为空，使用特殊字符#占位。

```java
public class Codec {
    public static int MAXN = 10001;

    public static TreeNode[] queue = new TreeNode[MAXN];

    public static int l, r;

    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        if (root != null) {
            l = r = 0;
            queue[r++] = root;
            sb.append(root.val).append(",");
            while (l < r) {
                root = queue[l++];
                if (root.left != null) {
                    queue[r++] = root.left;
                    sb.append(root.left.val).append(",");
                } else {
                    sb.append("#,");
                }
                if (root.right != null) {
                    queue[r++] = root.right;
                    sb.append(root.right.val).append(",");
                } else {
                    sb.append("#,");
                }
            }
        }
        return sb.toString();
    }

    public TreeNode deserialize(String data) {
        if ("".equals(data)) return null;
        String[] datas = data.split(",");
        int idx = 0;
        l = r = 0;
        TreeNode head = g(datas[idx++]);
        queue[r++] = head;
        while (l < r) {
            TreeNode cur = queue[l++];
            cur.left = g(datas[idx++]);
            cur.right = g(datas[idx++]);
            if (cur.left != null) {
                queue[r++] = cur.left;
            }
            if (cur.right != null) {
                queue[r++] = cur.right;
            }
        }
        return head;
    }

    private TreeNode g(String cur) {
        return "#".equals(cur) ? null : new TreeNode(Integer.parseInt(cur));
    }
}
```

# 题目7 : 利用先序与中序遍历序列构造二叉树

> https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

```java
public static TreeNode buildTree(int[] pre, int[] in) {
    if (pre == null || in == null || pre.length != in.length) {
        return null;
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < in.length; i++) {
        map.put(in[i], i);
    }
    return f(pre, 0, pre.length - 1, in, 0, in.length - 1, map);
}

private static TreeNode f(int[] pre, int l1, int r1, int[] in, int l2, int r2, HashMap<Integer, Integer> map) {
    if(l1 > r1) return null;
    TreeNode head = new TreeNode(pre[l1]);
    if (l1 == r1) {
        return head;
    }
    int k = map.get(pre[l1]);
    // pre : l1(........)[.......r1]
    // in  : (l2......)k[........r2]
    // (...)是左树对应，[...]是右树的对应
    head.left = f(pre, l1 + 1, l1 + k - l2, in, l2, k - 1, map);
    head.right = f(pre, l1 + k - l2 + 1, r1, in, k + 1, r2, map);
    return head;
}
```

# 题目8 : 验证完全二叉树

> https://leetcode.cn/problems/check-completeness-of-a-binary-tree/

**思路：**

1. 完全二叉树的非叶子节点一定是满树
2. 如果叶子节点，并且它是最后一个节点的情况下：左叶子一定不能为空，右可以为空
3. 使用宽度优先来进行遍历，然后判断其左右孩子节点以及叶子节点的情况

```java
// 如果测试数据量变大了就修改这个值
public static int MAXN = 101;

public static TreeNode[] queue = new TreeNode[MAXN];

public static int l, r;

// 完全二叉树：非叶子节点一定是满树
// 叶子节点，并且它是最后一个节点的情况下：左叶子一定不能为空，右可以为空
public static boolean isCompleteTree(TreeNode h) {
    if (h == null) {
        return true;
    }
    r = l = 0;
    queue[r++] = h;
    boolean leaf = false;
    while (l < r) {
        h = queue[l++];
        // 第一个条件：如果左为空，右不为空，那么一定不是
        if ((h.left == null && h.right != null)
                || (leaf && (h.left != null || h.right != null))) {
            return false;
        }
        if (h.left != null) {
            queue[r++] = h.left;
        }
        if (h.right != null) {
            queue[r++] = h.right;
        }
        if (h.left == null || h.right == null) {
            leaf = true;
        }
    }
    return true;
}
```

# 题目9 : 求完全二叉树的节点个数，要求时间复杂度低于O(n)

> https://leetcode.cn/problems/count-complete-tree-nodes/

**思路：**直接使用暴力解法进行求解

```java
// 暴力解，直接递归调用
public int countNodes(TreeNode root) {
    return f(root);
}

private int f(TreeNode root) {
    if (root == null) return 0;
    return f(root.left) + f(root.right) + 1;
}
```

**左神思路：**

```java
// 左神解：根据完全二叉树的性质求解
public static int countNodes1(TreeNode head) {
    if (head == null) {
        return 0;
    }
    return f(head, 1, mostLeft(head, 1));
}

// cur : 当前来到的节点
// level :  当前来到的节点在第几层
// h : 整棵树的高度，不是cur这棵子树的高度
// 求 : cur这棵子树上有多少节点
public static int f(TreeNode cur, int level, int h) {
    if (level == h) {
        return 1;
    }
    if (mostLeft(cur.right, level + 1) == h) {
        // cur右树上的最左节点，扎到了最深层
        return (1 << (h - level)) + f(cur.right, level + 1, h);
    } else {
        // cur右树上的最左节点，没扎到最深层
        return (1 << (h - level - 1)) + f(cur.left, level + 1, h);
    }
}

// 当前节点是cur，并且它在level层
// 返回从cur开始不停往左，能扎到几层
public static int mostLeft(TreeNode cur, int level) {
    while (cur != null) {
        level++;
        cur = cur.left;
    }
    return level - 1;
}
```