# 二叉树高频题目

这一期和下一期视频，会讲解二叉树高频题目，但是不含树型dp的题目

树型dp问题，会放在【必备】课程的动态规划大章节部分讲述

树型dp中的换根dp问题，会放在【扩展】课程的动态规划大章节部分讲述

AVL树的实现，树的左旋、右旋，这些内容也会在【扩展】课程里讲述	

# 题目1 : 二叉树的层序遍历

> 

思路：

1. 准备一个队列
2. x弹出
3. x 有左加左，有右加右
4. 用一个hashMap记录下当前node属于哪一行，只有当来到下一行的时候，初始化下一行的ans：ans.size() == lev

普通版本：

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    if (root != null) {
        Queue<TreeNode> queue = new LinkedList<>();
        HashMap<TreeNode, Integer> levs = new HashMap<>();
        queue.add(root);
        levs.put(root, 0);
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            int lev = levs.get(cur);
            if (ans.size() == lev) {
                // init lev ans
                ans.add(new ArrayList<>());
            }
            ans.get(lev).add(cur.val);
            if (cur.left != null) {
                queue.add(cur.left);
                levs.put(cur.left, lev + 1);
            }
            if (cur.right != null) {
                queue.add(cur.right);
                levs.put(cur.right, lev + 1);
            }
        }
    }
    return ans;
}
```

**优化版本：**使用数组代替队列，并且一次性收集某一高度的答案，

```java
// 如果测试数据量变大了就修改这个值
    public static int MAXN = 2001;
    // 使用数组代替队列结构
    public static TreeNode[] queue = new TreeNode[MAXN];

    public static int l, r;

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root != null) {
            l = r = 0;
            queue[r++] = root;
            while (l < r) {
                // 一次遍历一行的数据
                int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
                List<Integer> levAns = new ArrayList<>();
              // 也可以先收集答案，再进行弹出遍历
//                for (int i = l; i < r ; i++) {
//                    levAns.add(queue[i].val);
//                }
                for (int i = 0; i < size; i++) {
                    TreeNode cur = queue[l++];
                    levAns.add(cur.val);
                    if (cur.left != null) {
                        queue[r++] = cur.left;
                    }
                    if (cur.right != null) {
                        queue[r++] = cur.right;
                    }
                }
                ans.add(levAns);

            }
        }
        return ans;
    }
```

# 题目2 : 二叉树的锯齿形层序遍历

> https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/

思路：

1. 使用标准的BFS，进行宽度优先遍历
2. 使用一个标记位flag，记录下正序还是倒序记录，
3. 正序：l …… r-l
4. 倒序：r-l …… l
5. 先收集答案，再进行弹出，放入左右孩子，进行宽度优先遍历

```java
// 如果测试数据量变大了就修改这个值
public static int MAXN = 2001;
// 使用数组代替队列结构
public static TreeNode[] queue = new TreeNode[MAXN];

public static int l, r;

public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
    List<List<Integer>> ans = new ArrayList<>();
    boolean reverse = false;
    if (root != null) {
        l = r = 0;
        queue[r++] = root;
        while (l < r) {
            // 一次遍历一行的数据
            int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
            List<Integer> levAns = new ArrayList<>();
            // 先收集答案，一次收集一正行的数据
            // reverse = false ：l    -》 r-l
            // reverse = true  : r-l  -》 l
            if (!reverse) {
                for (int i = l; i < r; i++) {
                    levAns.add(queue[i].val);
                }
            } else {
                for (int i = r - 1; i >= l; i--) {
                    levAns.add(queue[i].val);
                }
            }
            // 然后宽度遍历
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue[l++];
                if (cur.left != null) {
                    queue[r++] = cur.left;
                }
                if (cur.right != null) {
                    queue[r++] = cur.right;
                }
            }
            reverse = !reverse;
            ans.add(levAns);
        }
    }
    return ans;
}
```

# 题目3 : 二叉树的最大特殊宽度

> https://leetcode.cn/problems/maximum-width-of-binary-tree/description/

**思路：**

1. 使用标准的BFS，进行宽度优先遍历
2. 准备一个index 队列，跟标准的宽度优先遍历队列一样，
3. 只是这个index队列 存的是每个值所对应的 index 值，
4. 比如：cur node的位置为index，左：index*2，右：index * 2 + 1

**问题：**为什么要记录idx，为的是，不管null的位置，只需要知道当前行，最左和最右位置，直接相减+1，就是当前行最大宽度

```java
// 如果测试数据量变大了就修改这个值
public static int MAXN = 3001;
// 使用数组代替队列结构
public static TreeNode[] queue = new TreeNode[MAXN];
public static Integer[] iq = new Integer[MAXN];

public static int l, r;

public int widthOfBinaryTree(TreeNode root) {
    int ans = 0;
    if (root != null) {
        l = r = 0;
        queue[r] = root;
        iq[r++] = 1;
        while (l < r) {
            // 一次遍历一行的数据
            int size = r - l; // 遍历多长，提前计算好，因为每次遍历加入数据的时候都会更改r和l
            // 当前正行的开始位置l，结束位置 r - 1
            ans = Math.max(ans, iq[r - 1] - iq[l] + 1);
            // 然后宽度遍历
            for (int i = 0; i < size; i++) {
                TreeNode cur = queue[l];
                Integer idx = iq[l++];
                if (cur.left != null) {
                    queue[r] = cur.left;
                    iq[r++] = idx * 2;
                }
                if (cur.right != null) {
                    queue[r] = cur.right;
                    iq[r++] = idx * 2 + 1;
                }
            }
        }
    }
    return ans;
}
```

# 题目4 : 求二叉树的最大深度、求二叉树的最小深度

> 

# 题目5 : 二叉树先序序列化和反序列化

> 

# 题目6 : 二叉树按层序列化和反序列化

> 

# 题目7 : 利用先序与中序遍历序列构造二叉树

> 

# 题目8 : 验证完全二叉树

> 

# 题目9 : 求完全二叉树的节点个数，要求时间复杂度低于O(n)

> 